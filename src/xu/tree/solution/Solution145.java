package xu.tree.solution;

public class Solution145 {
    /*
     *
     * 二叉树后序遍历：单栈写法
     *
     * 实际上，我们可以只使用一个栈去模拟后序遍历，但是会比较麻烦。为了避免问题变得复杂，我们可以先考虑一下能不能借鉴一下前序遍历的思路。
     * 首先，我们很确定的是，后序遍历的开头和前序遍历是可以一样的，都是先经过二叉树的最左分支，直到经过的节点是个叶子节点（没有左右孩子）为止。
     *
     * 代码如下：
     *
     * while(cur!=null) { // 经过所有左节点
     *    s.push(cur);
     *    cur = cur.left;
     * }
     *
     * 接下来很关键，我们得考虑什么时候才能访问节点。首先我们可以很确定一种情况：发现是叶子节点，必然会访问。这是第一种情况。
     *
     * 我们回想前序遍历和中序遍历的时候，它们经过的路径都是左根右，对于前序和中序来说，访问路径基本上跟经过路径是一致的。但是在后序遍历中，我们先经过根节点，但是我们不会去访问它。
     * 而是会选择先访问它的右子节点。所以在这种情况下，我们会将根节点留在栈中不弹出，等到需要访问它的时候再出。
     *
     * 那么，什么时候才需要访问根节点呢？答案当然就是访问完右子节点之后了。我们如何获取这个信息？这并不难，我们可以记录一下上一次访问的节点，然后判断一下当前经过的节点和上一次。
     * 访问的节点是什么关系就好了。如果当前经过的节点的右子节点是上一次访问的节点，显然我们需要访问当前节点了。这是第二种情况。
     *
     * 总结起来，我们什么时候才能访问节点。有如下两种情况：
     * i.当前经过节点是叶子节点。
     * ii.当前经过节点的右子节点是上一次访问的节点。
     */
}
