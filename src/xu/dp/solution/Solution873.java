package xu.dp.solution;

public class Solution873 {
    /*
     * 将斐波那契式的子序列中的两个连续项 A[i], A[j] 视为单个结点 (i, j)，整个子序列是这些连续结点之间的路径。
     *
     * 例如，对于斐波那契式的子序列 (A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)，结点之间的路径为
     * (1, 2) <-> (2, 4) <-> (4, 7) <-> (7, 10)。
     *
     * 这样做的动机是，只有当 A[i] + A[j] == A[k] 时，两结点 (i, j) 和 (j, k) 才是连通的，我们需要这些信息才能知道这一连通。
     * 现在我们得到一个类似于【最长上升子序列】的问题。
     *
     * 设 dp[i, j] 是结束在 [i, j] 的最长路径。那么 如果 (i, j) 和 (j, k) 是连通的， dp[j, k] = dp[i, j] + 1
     */
}
