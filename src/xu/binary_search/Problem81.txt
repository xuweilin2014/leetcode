第一类
1011110111 和 1110111101 这种。此种情况下 nums[start] = nums[mid] && nums[end] == nums[mid]，分不清到底是前面有序还是后面有序，
此时 start++ 即可。相当于去掉一个重复的干扰项。

第二类
22 33 44 55 66 77 11 这种，也就是 nums[start] <= nums[mid]。此例子中就是 2 < 5；
这种情况下，前半部分有序。因此如果 nums[start] <= target < nums[mid]，则在前半部分找，否则去后半部分找。

第三类
66 77 11 22 33 44 55 这种，也就是 nums[mid] <= nums[end]。此例子中就是 22 < 55；
这种情况下，后半部分有序。因此如果 nums[mid] < target <= nums[end]。则在后半部分找，否则去前半部分找。
