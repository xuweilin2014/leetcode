package xu.backtracking.solutions;

public class Solution1079 {
    /*
     * 活字印刷
     *
     * 前面介绍的几个组合的回溯算法，因为结果不能有重复的（比如 [1，3] 和 [3，1] 被认为是重复的结果），所以每次选择的时候都只能从前往后选。
     * 但这题中子集 [A，B] 和 [B，A] 被认为是两种不同的结果，所以每次都要从头开始选择，因为每个字符只能被使用一次，所以如果使用之后下次就不
     * 能再使用了，这里可以使用一个数组 visited 来标记有没有被使用。
     *
     * 但这里有个难点就是怎么过滤掉重复的部分。举个例子，比如 ABBCD，如果我们选择了第 1 个 B，那么剩余的字符就变成了
     * ABCD，这个时候我们再选择第 2 个 B 是可以的。但如果我们没选择第 1 个 B，直接选择第 2 个 B，那么剩余的字符就是 ABCD，和上面重复了。
     * 所以代码大致是这样的:
     *
     * if (i - 1 >= 0 && chars[i] == chars[i - 1] && !used[i - 1])
     *          continue;
     */
}
